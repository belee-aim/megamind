"""
Seed best practice knowledge to Titan service.

Usage:
    uv run python scripts/seed_best_practices.py

Environment:
    TITAN_API_URL: Titan service URL (default: http://localhost:8001)
"""

import asyncio
import os
from dataclasses import dataclass, field

import httpx

TITAN_API_URL = os.getenv("TITAN_API_URL", "http://localhost:8001")


@dataclass
class BestPractice:
    """Best practice knowledge entry for Titan API."""

    title: str
    content: str
    summary: str
    doctype_name: str | None = None
    related_doctypes: list[str] = field(default_factory=list)
    module: str | None = None
    priority: int = 50  # 1-100, higher = more important
    meta_data: dict = field(default_factory=dict)

    def to_api_payload(self) -> dict:
        """Convert to Titan API request format."""
        return {
            "title": self.title,
            "content": self.content,
            "summary": self.summary,
            "doctype_name": self.doctype_name,
            "related_doctypes": self.related_doctypes,
            "module": self.module,
            "priority": self.priority,
            "meta_data": self.meta_data,
            # Note: embedding, id, ref_id, version are generated by Titan
        }


# =============================================================================
# BEST PRACTICES KNOWLEDGE BASE
# =============================================================================

BEST_PRACTICES: list[BestPractice] = [
    # -------------------------------------------------------------------------
    # SALES ORDER
    # -------------------------------------------------------------------------
    BestPractice(
        title="Sales Order - Always set delivery date before submission",
        summary="Set delivery_date field to avoid validation errors when creating Sales Orders.",
        content="""
## Best Practice: Set Delivery Date Before Submission

When creating a Sales Order, always set the `delivery_date` field before saving or submitting.

### Why This Matters
- `delivery_date` is a mandatory field for submission
- It affects Material Request planning
- Delivery Note scheduling depends on this date

### Recommended Approach
1. If customer specifies delivery date, use that
2. If not specified, calculate from transaction_date + default lead time
3. Check Item's `lead_time_days` for item-specific lead times

### Example
```python
# Set delivery date if not provided
if not doc.delivery_date:
    doc.delivery_date = frappe.utils.add_days(doc.transaction_date, 7)

# Or use item-specific lead time
for item in doc.items:
    item_lead_time = frappe.db.get_value("Item", item.item_code, "lead_time_days") or 7
    if not item.delivery_date:
        item.delivery_date = frappe.utils.add_days(doc.transaction_date, item_lead_time)
```

### Common Errors Prevented
- "delivery_date is a mandatory field"
- "Row #X: Delivery Date is required"
""",
        doctype_name="Sales Order",
        related_doctypes=["Delivery Note", "Material Request"],
        module="Selling",
        priority=80,
        meta_data={
            "operation": "create",
            "content_type": "best_practice",
            "tags": ["validation", "mandatory-field", "delivery"],
        },
    ),
    BestPractice(
        title="Sales Order - Verify customer credit limit before creation",
        summary="Check customer outstanding amount against credit limit to avoid payment collection issues.",
        content="""
## Best Practice: Verify Customer Credit Limit

Before creating a Sales Order, verify the customer hasn't exceeded their credit limit.

### Why This Matters
- Prevents orders for customers with payment issues
- Avoids delivery of goods that may not be paid for
- Maintains healthy cash flow

### How to Check
1. Get customer's `credit_limit` from Customer master
2. Get `outstanding_amount` from Customer
3. Compare: outstanding + new order total <= credit_limit

### Implementation
```python
def check_credit_limit(customer, new_order_total):
    customer_doc = frappe.get_doc("Customer", customer)
    credit_limit = customer_doc.credit_limit or 0
    outstanding = get_customer_outstanding(customer)

    if credit_limit > 0 and (outstanding + new_order_total) > credit_limit:
        frappe.throw(f"Customer {customer} has exceeded credit limit. "
                    f"Outstanding: {outstanding}, Limit: {credit_limit}")
```

### When to Bypass
- Customer has `bypass_credit_limit_check` enabled
- User has "Credit Controller" role
- Order is prepaid (Advance Payment)
""",
        doctype_name="Sales Order",
        related_doctypes=["Customer", "Sales Invoice", "Payment Entry"],
        module="Selling",
        priority=75,
        meta_data={
            "operation": "create",
            "content_type": "best_practice",
            "tags": ["credit-limit", "validation", "accounts"],
        },
    ),
    BestPractice(
        title="Sales Order - Include all required item fields",
        summary="Ensure item rows have item_code, qty, rate, and delivery_date to avoid validation errors.",
        content="""
## Best Practice: Complete Item Row Fields

When adding items to a Sales Order, ensure all required fields are populated.

### Required Item Fields
| Field | Type | Description |
|-------|------|-------------|
| item_code | Link | Required - must exist in Item master |
| qty | Float | Required - must be > 0 |
| rate | Currency | Price per unit (can be 0 for free items) |
| delivery_date | Date | Required for submission |
| uom | Link | Unit of measure (defaults from Item) |

### Optional but Recommended
- warehouse: Source warehouse for delivery
- description: Auto-fetched from Item if not set
- item_name: Auto-fetched from Item

### Example Payload
```json
{
    "items": [
        {
            "item_code": "ITEM-001",
            "qty": 10,
            "rate": 100.00,
            "delivery_date": "2024-12-25",
            "warehouse": "Finished Goods - ABC"
        }
    ]
}
```

### Common Errors
- "item_code is required in row X"
- "qty must be greater than 0"
- "Delivery Date required for Item ITEM-001"
""",
        doctype_name="Sales Order",
        related_doctypes=["Sales Order Item", "Item"],
        module="Selling",
        priority=85,
        meta_data={
            "operation": "create",
            "content_type": "best_practice",
            "tags": ["items", "validation", "child-table"],
        },
    ),
    # -------------------------------------------------------------------------
    # STOCK ENTRY
    # -------------------------------------------------------------------------
    BestPractice(
        title="Stock Entry - Verify stock availability before Material Transfer",
        summary="Always check actual_qty in source warehouse before creating transfer entries.",
        content="""
## Best Practice: Verify Stock Before Transfer

Before creating a Stock Entry of type "Material Transfer", verify sufficient stock exists.

### Why This Matters
- Prevents negative stock (if not allowed)
- Avoids failed submissions
- Ensures accurate inventory records

### How to Check Stock
```python
from frappe.utils import flt

def check_stock_availability(item_code, warehouse, required_qty):
    bin_data = frappe.db.get_value(
        "Bin",
        {"item_code": item_code, "warehouse": warehouse},
        ["actual_qty", "reserved_qty"],
        as_dict=True
    ) or {"actual_qty": 0, "reserved_qty": 0}

    available_qty = flt(bin_data.actual_qty) - flt(bin_data.reserved_qty)

    if available_qty < required_qty:
        frappe.throw(
            f"Insufficient stock for {item_code} in {warehouse}. "
            f"Available: {available_qty}, Required: {required_qty}"
        )
```

### Stock Entry Types That Need This Check
- Material Transfer
- Material Issue
- Send to Subcontractor

### Stock Entry Types That Don't Need This
- Material Receipt (adding stock)
- Manufacture (uses BOM)
""",
        doctype_name="Stock Entry",
        related_doctypes=["Bin", "Warehouse", "Item"],
        module="Stock",
        priority=80,
        meta_data={
            "operation": "create",
            "content_type": "best_practice",
            "tags": ["stock", "validation", "inventory"],
        },
    ),
    BestPractice(
        title="Stock Entry - Set correct stock_entry_type",
        summary="Choose the appropriate stock_entry_type based on the operation being performed.",
        content="""
## Best Practice: Choose Correct Stock Entry Type

The `stock_entry_type` field determines the behavior and validations of a Stock Entry.

### Available Types and When to Use

| Type | Use Case | Source WH | Target WH |
|------|----------|-----------|-----------|
| Material Receipt | Receiving goods (no PO) | - | Required |
| Material Issue | Consuming/scrapping items | Required | - |
| Material Transfer | Moving between warehouses | Required | Required |
| Material Transfer for Manufacture | BOM component transfer | Required | Required |
| Manufacture | Creating finished goods from BOM | Required | Required |
| Repack | Combining/splitting items | Required | Required |
| Send to Subcontractor | Sending for job work | Required | Required |

### Example Usage
```python
# Material Transfer between warehouses
stock_entry = frappe.new_doc("Stock Entry")
stock_entry.stock_entry_type = "Material Transfer"
stock_entry.append("items", {
    "item_code": "ITEM-001",
    "qty": 10,
    "s_warehouse": "Raw Materials - ABC",  # Source
    "t_warehouse": "Finished Goods - ABC",  # Target
})

# Material Receipt (no source warehouse)
stock_entry = frappe.new_doc("Stock Entry")
stock_entry.stock_entry_type = "Material Receipt"
stock_entry.append("items", {
    "item_code": "ITEM-001",
    "qty": 10,
    "t_warehouse": "Raw Materials - ABC",  # Target only
    "basic_rate": 100,  # Required for valuation
})
```

### Common Errors
- "Source Warehouse is mandatory for row X" (wrong type for receipt)
- "Target Warehouse is mandatory for row X" (wrong type for issue)
""",
        doctype_name="Stock Entry",
        related_doctypes=["Stock Entry Type", "Warehouse"],
        module="Stock",
        priority=85,
        meta_data={
            "operation": "create",
            "content_type": "best_practice",
            "tags": ["stock-entry-type", "warehouse", "inventory"],
        },
    ),
    # -------------------------------------------------------------------------
    # PURCHASE ORDER
    # -------------------------------------------------------------------------
    BestPractice(
        title="Purchase Order - Validate supplier and item compatibility",
        summary="Ensure the supplier is authorized to provide the items being ordered.",
        content="""
## Best Practice: Validate Supplier-Item Relationship

Before creating a Purchase Order, verify the supplier can provide the requested items.

### Why This Matters
- Some items have authorized suppliers only
- Price lists may be supplier-specific
- Lead times vary by supplier

### How to Validate
```python
def validate_supplier_item(supplier, item_code):
    # Check if Item Supplier exists
    item_supplier = frappe.db.exists(
        "Item Supplier",
        {"parent": item_code, "supplier": supplier}
    )

    item = frappe.get_doc("Item", item_code)

    # If item has suppliers defined, must match
    if item.supplier_items and not item_supplier:
        frappe.throw(
            f"Supplier {supplier} is not authorized for Item {item_code}. "
            f"Authorized suppliers: {[s.supplier for s in item.supplier_items]}"
        )
```

### Benefits
- Automatic price fetching from Item Supplier
- Correct lead time calculation
- Supplier part number mapping
""",
        doctype_name="Purchase Order",
        related_doctypes=["Supplier", "Item", "Item Supplier"],
        module="Buying",
        priority=70,
        meta_data={
            "operation": "create",
            "content_type": "best_practice",
            "tags": ["supplier", "validation", "procurement"],
        },
    ),
    # -------------------------------------------------------------------------
    # PAYMENT ENTRY
    # -------------------------------------------------------------------------
    BestPractice(
        title="Payment Entry - Match payment to correct invoices",
        summary="Use references table to allocate payment amounts to specific invoices.",
        content="""
## Best Practice: Proper Invoice Allocation

When creating Payment Entry, always link to the correct invoices for proper accounting.

### Why This Matters
- Maintains accurate outstanding amounts
- Enables proper aging reports
- Required for reconciliation

### Payment Entry Structure
```python
payment = frappe.new_doc("Payment Entry")
payment.payment_type = "Receive"  # or "Pay"
payment.party_type = "Customer"  # or "Supplier"
payment.party = "CUST-001"
payment.paid_amount = 1000
payment.received_amount = 1000
payment.paid_from = "Debtors - ABC"
payment.paid_to = "Cash - ABC"

# Link to specific invoices
payment.append("references", {
    "reference_doctype": "Sales Invoice",
    "reference_name": "SINV-00001",
    "allocated_amount": 600,
})
payment.append("references", {
    "reference_doctype": "Sales Invoice",
    "reference_name": "SINV-00002",
    "allocated_amount": 400,
})
```

### Key Rules
- Sum of allocated_amount must equal paid_amount
- reference_doctype must match party_type (Sales Invoice for Customer)
- Invoice must be submitted and have outstanding > 0

### Common Errors
- "Allocated amount cannot be greater than outstanding"
- "Total allocated must equal paid amount"
""",
        doctype_name="Payment Entry",
        related_doctypes=["Sales Invoice", "Purchase Invoice", "Customer", "Supplier"],
        module="Accounts",
        priority=80,
        meta_data={
            "operation": "create",
            "content_type": "best_practice",
            "tags": ["payment", "allocation", "reconciliation"],
        },
    ),
    # -------------------------------------------------------------------------
    # GENERAL
    # -------------------------------------------------------------------------
    BestPractice(
        title="General - Always use correct warehouse for company",
        summary="Warehouse must belong to the same company as the transaction.",
        content="""
## Best Practice: Match Warehouse to Company

Every warehouse belongs to a specific company. Transactions must use warehouses from the same company.

### Why This Matters
- Stock ledger is company-specific
- Accounting entries require matching company
- Prevents cross-company stock errors

### How to Validate
```python
def validate_warehouse_company(warehouse, company):
    warehouse_company = frappe.db.get_value("Warehouse", warehouse, "company")

    if warehouse_company != company:
        frappe.throw(
            f"Warehouse {warehouse} belongs to {warehouse_company}, "
            f"not {company}"
        )
```

### Common Patterns
- "Stores - ABC" belongs to company "ABC"
- Child warehouses inherit parent's company
- Cannot transfer stock between companies directly

### Affected DocTypes
- Stock Entry
- Delivery Note
- Purchase Receipt
- Sales Order (for reserved warehouse)
- Purchase Order (for target warehouse)
""",
        doctype_name=None,  # General best practice
        related_doctypes=["Warehouse", "Stock Entry", "Delivery Note", "Purchase Receipt"],
        module="Stock",
        priority=90,
        meta_data={
            "operation": "create",
            "content_type": "best_practice",
            "tags": ["warehouse", "company", "validation", "general"],
        },
    ),
    BestPractice(
        title="General - Document naming series must match company",
        summary="Use correct naming series prefix that matches the transaction company.",
        content="""
## Best Practice: Correct Naming Series

Each company typically has its own naming series prefix. Use the correct one.

### Why This Matters
- Document numbering should identify company
- Prevents duplicate numbers across companies
- Required for multi-company setups

### How Naming Series Work
```
Format: {prefix}.{separator}{series}
Example: SO-ABC-.YYYY.-  → SO-ABC-2024-00001
```

### Common Patterns
| Company | Prefix Example |
|---------|---------------|
| ABC Company | SO-ABC-, SINV-ABC- |
| XYZ Corp | SO-XYZ-, SINV-XYZ- |

### Best Practice
```python
# Let ERPNext auto-select based on company
doc = frappe.new_doc("Sales Order")
doc.company = "ABC Company"
# naming_series will be auto-set if configured

# Or explicitly set
doc.naming_series = "SO-ABC-.YYYY.-"
```

### Configuration
- Setup in: Selling Settings, Buying Settings, Stock Settings
- Or in DocType's naming_series options
""",
        doctype_name=None,
        related_doctypes=["Sales Order", "Purchase Order", "Sales Invoice"],
        module="Setup",
        priority=60,
        meta_data={
            "operation": "create",
            "content_type": "best_practice",
            "tags": ["naming-series", "company", "configuration"],
        },
    ),
    # -------------------------------------------------------------------------
    # PLANNING & SCHEDULING
    # -------------------------------------------------------------------------
    BestPractice(
        title="Planning - Use item-specific lead times for accurate scheduling",
        summary="Fetch lead_time_days from Item master for precise MR and Production scheduling.",
        content="""
## Best Practice: Use Item-Specific Lead Times

Always use the `lead_time_days` field from Item master instead of hardcoded defaults for accurate planning.

### Why This Matters
- Different items have different procurement/manufacturing times
- Generic lead times cause late deliveries or excess inventory
- Material Request and Production Planning depend on accurate lead times

### Where Lead Time is Stored
```
Item DocType:
├── lead_time_days (Int): Default lead time for this item
├── safety_stock (Float): Minimum stock to maintain
└── Item Supplier (Child Table):
    └── supplier: Supplier name
    └── supplier_lead_time: Supplier-specific lead time
```

### How to Fetch Lead Time
```python
def get_item_lead_time(item_code, supplier=None):
    \"\"\"Get lead time for an item, optionally for specific supplier.\"\"\"

    # Check supplier-specific lead time first
    if supplier:
        supplier_lead_time = frappe.db.get_value(
            "Item Supplier",
            {"parent": item_code, "supplier": supplier},
            "supplier_lead_time"
        )
        if supplier_lead_time:
            return supplier_lead_time

    # Fall back to item default lead time
    item_lead_time = frappe.db.get_value("Item", item_code, "lead_time_days")

    # Use system default if not set (e.g., 7 days)
    return item_lead_time or frappe.db.get_single_value("Stock Settings", "default_lead_time_days") or 7
```

### Usage in Sales Order
```python
def set_delivery_dates(doc):
    \"\"\"Set delivery dates based on item-specific lead times.\"\"\"
    for item in doc.items:
        if not item.delivery_date:
            lead_time = get_item_lead_time(item.item_code)
            item.delivery_date = frappe.utils.add_days(
                doc.transaction_date,
                lead_time
            )
```

### Usage in Material Request
```python
def calculate_required_by_date(item_code, delivery_date):
    \"\"\"Calculate when materials must arrive for on-time delivery.\"\"\"
    lead_time = get_item_lead_time(item_code)
    # MR should be fulfilled lead_time days before delivery
    return frappe.utils.add_days(delivery_date, -lead_time)
```

### Best Practices
1. **Set lead_time_days on all Items** - Don't rely on defaults
2. **Use supplier-specific lead times** for purchased items
3. **Include buffer time** for critical items (safety margin)
4. **Review periodically** - Lead times change with suppliers/processes

### Impact on ERPNext Features
| Feature | How Lead Time is Used |
|---------|----------------------|
| Material Request | Calculates required_by_date |
| Production Plan | Schedules work orders |
| Sales Order | Suggests realistic delivery dates |
| Reorder Level | Triggers reorder at right time |
| Projected Qty | Forecasts future availability |

### Common Errors Prevented
- Late deliveries due to underestimated lead times
- Excess inventory from over-ordering too early
- Production delays waiting for materials
- Customer complaints from missed delivery dates
""",
        doctype_name="Item",
        related_doctypes=["Material Request", "Sales Order", "Production Plan", "Item Supplier", "Stock Settings"],
        module="Stock",
        priority=75,
        meta_data={
            "operation": "read",
            "content_type": "best_practice",
            "tags": ["lead-time", "planning", "scheduling", "mrp", "inventory"],
        },
    ),
]


# =============================================================================
# API CLIENT
# =============================================================================


async def send_to_titan(practice: BestPractice) -> dict:
    """Send a best practice to Titan API."""
    async with httpx.AsyncClient(timeout=30.0) as client:
        response = await client.post(
            f"{TITAN_API_URL}/api/v1/erpnext-knowledge",
            json=practice.to_api_payload(),
        )
        response.raise_for_status()
        return response.json()


async def main():
    """Seed all best practices to Titan."""
    print(f"Seeding {len(BEST_PRACTICES)} best practices to Titan at {TITAN_API_URL}")
    print("-" * 60)

    results = {"success": 0, "failed": 0, "errors": []}

    for practice in BEST_PRACTICES:
        try:
            response = await send_to_titan(practice)
            print(f"✓ {practice.title}")
            results["success"] += 1
        except httpx.HTTPStatusError as e:
            print(f"✗ {practice.title}: HTTP {e.response.status_code}")
            results["failed"] += 1
            results["errors"].append(
                {"title": practice.title, "error": e.response.text}
            )
        except Exception as e:
            print(f"✗ {practice.title}: {e}")
            results["failed"] += 1
            results["errors"].append({"title": practice.title, "error": str(e)})

    print("-" * 60)
    print(f"Results: {results['success']} success, {results['failed']} failed")

    if results["errors"]:
        print("\nErrors:")
        for err in results["errors"]:
            print(f"  - {err['title']}: {err['error'][:100]}")


if __name__ == "__main__":
    asyncio.run(main())
